


<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Chess 2</title>
        <script src="/src/loadImages.js"></script>

        <script src="/src/variables.js"></script>

        <script src="/src/jsonfn.js"></script>

        <script src="src/selectAndMoveMethods.js"></script>
        <script type="module" src="src/pieceDefinitions.js"></script>
        <script src="/src/globby.js"></script>
        <script type="module" src="/src/helperFunctions.js"></script>
        <script src="/src/AI.js"></script>

        <link rel="stylesheet" href="/src/main.css">

</head>

<body>
    <div class="container">
        <canvas id="canvas" width="500" height="500"></canvas>
        <div class="times">
            <h1 class="clock" id="blackClock"></h1>
            <button class="row exitButton" style="display:none;" id="exitButton"><span id="forfeitText" class="forfeitText">Game Continues</span> <img id="flagImage" style="width:50px; height:50px;" src="/static/whiteFlag.svg" alt="" /></button>

            <h1 class="clock" id="whiteClock"></h1>
        </div>
        <div class="row message">
            <h3 id="turn"></h3>
        </div>

    </div>

</body>



<script type="module">
import {getParams, getSinglePlayerGame, raceChoiceChess, getMaxX, getMousePos, pieceFromXY, lightBoardFE, findSquareByXY} from './src/helperFunctions.js';
function drawPiece(x, y, img, size) {
    if(size == undefined){
        size = 50
    }
    switch (img) {
        case 'blackBishop.png':
            
            ctx.drawImage(bBishop, 0, 0, 500, 500, x * size, y * size, size, size);
            break;
        case 'dragonImage':
            ctx.drawImage(dragonImage, 0, 0, 500, 500, x * size, y * size, size, size);
            break;
        case 'whiteBishop.png':
            ctx.drawImage(wBishop, 0, 0, 500, 500, x * size, y * size, size, size);
            break;
        case 'blackKnight.png':
            ctx.drawImage(bKnight, 0, 0, 500, 500, x * size, y * size, size, size);
            break;
        case 'whiteKnight.png':
            wKnight.width = size;
            wKnight.height = size;
            ctx.drawImage(wKnight, 0, 0, 500, 500, x * size, y * size, size, size);
            break;
        case 'blackRook.png':
            ctx.drawImage(bRook, 0, 0, 500, 500, x * size, y * size, size, size);
            break;
        case 'whiteRook.png':
            ctx.drawImage(wRook, 0, 0, 500, 500, x * size, y * size, size, size);
            break;
        case 'blackPawn.png':
            ctx.drawImage(bPawn, 0, 0, 500, 500, x * size, y * size, size, size);
            break;
        case 'whitePawn.png':
            ctx.drawImage(wPawn, 0, 0, 500, 500, x * size, y * size, size, size);
            break;
        case 'blackQueen.png':
            ctx.drawImage(bQueen, 0, 0, 500, 500, x * size, y * size, size, size);
            break;
        case 'whiteQueen.png':
            ctx.drawImage(wQueen, 0, 0, 500, 500, x * size, y * size, size, size);
            break;
        case 'blackKing.png':
            ctx.drawImage(bKing, 0, 0, 500, 500, x * size, y * size, size, size);
            break;
        case 'whiteKing.png':
            ctx.drawImage(wKing, 0, 0, 500, 500, x * size, y * size, size, size);
            break;
        case 'blackPig.png':
            ctx.drawImage(bPig, 0, 0, 500, 500, x * size, y * size, size, size);
            break;
        case 'whitePig.png':
            ctx.drawImage(wPig, 0, 0, 500, 500, x * size, y * size, size, size);
            break;
        case 'blackHorse.png':
            ctx.drawImage(bHorse, 0, 0, 500, 500, x * size, y * size, size, size);
            break;
        case 'whiteHorse.png':
            ctx.drawImage(wHorse, 0, 0, 500, 500, x * size, y * size, size, size);
            break;
        case 'blackRicar.png':
            ctx.drawImage(bRicar, 0, 0, 500, 500, x * size, y * size, size, size);
            break;
        case 'whiteRicar.png':
            ctx.drawImage(wRicar, 0, 0, 500, 500, x * size, y * size, size, size);
            break;
        case 'blackPlagueDoctor.png':
            ctx.drawImage(bPlagueDoctor, 0, 0, 500, 500, x * size, y * size, size, size);
            break;
        case 'whitePlagueDoctor.png':
            ctx.drawImage(wPlagueDoctor, 0, 0, 500, 500, x * size, y * size, size, size);
            break;

        case 'blackStarMan.png':
            ctx.drawImage(bStarMan, 0, 0, 500, 500, x * size, y * size, size, size);
            break;
        case 'whiteStarMan.png':
            ctx.drawImage(wStarMan, 0, 0, 500, 500, x * size, y * size, size, size);
            break;
        case 'blackClown.png':
            ctx.drawImage(bClown, 0, 0, 500, 500, x * size, y * size, size, size);
            break;
        case 'whiteClown.png':
            ctx.drawImage(wClown, 0, 0, 500, 500, x * size, y * size, size, size);
            break;
        case 'blackGhost.png':
            ctx.drawImage(bGhost, 0, 0, 500, 500, x * size, y * size, size, size);
            break;
        case 'whiteGhost.png':
            ctx.drawImage(wGhost, 0, 0, 500, 500, x * size, y * size, size, size);
            break;
        case 'blackHat.png':
            ctx.drawImage(bHat, 0, 0, 500, 500, x * size, y * size, size, size);
            break;
        case 'whiteHat.png':
            ctx.drawImage(wHat, 0, 0, 500, 500, x * size, y * size, size, size);
            break;
        // 
        case 'blackAnt.png':
            ctx.drawImage(bAnt, 0, 0, 500, 500, x * size, y * size, size, size);
            break;
        case 'blackGoliathBug.png':
            ctx.drawImage(bGoliathBug, 0, 0, 500, 500, x * size, y * size, size, size);
            break;
        case 'blackLadyBug.png':
            ctx.drawImage(bLadyBug, 0, 0, 500, 500, x * size, y * size, size, size);
            break;
        case 'blackSpider.png':
            ctx.drawImage(bSpider, 0, 0, 500, 500, x * size, y * size, size, size);
            break;
        case 'blackQueenBug.png':
            ctx.drawImage(bQueenBug, 0, 0, 500, 500, x * size, y * size, size, size);
            break;
        case 'blackShroom.png':
            ctx.drawImage(bShroom, 0, 0, 500, 500, x * size, y * size, size, size);
            break;

        case 'whiteAnt.png':
            ctx.drawImage(wAnt, 0, 0, 500, 500, x * size, y * size, size, size);
            break;
        case 'whiteGoliathBug.png':
            ctx.drawImage(wGoliathBug, 0, 0, 500, 500, x * size, y * size, size, size);
            break;
        case 'whiteLadyBug.png':
            ctx.drawImage(wLadyBug, 0, 0, 500, 500, x * size, y * size, size, size);
            break;
        case 'whiteSpider.png':
            ctx.drawImage(wSpider, 0, 0, 500, 500, x * size, y * size, size, size);
            break;
        case 'whiteQueenBug.png':
            ctx.drawImage(wQueenBug, 0, 0, 500, 500, x * size, y * size, size, size);
            break;
        case 'whiteShroom.png':
            ctx.drawImage(wShroom, 0, 0, 500, 500, x * size, y * size, size, size);
            break;

            //New
        case 'whiteSwordsmen.png':
            ctx.drawImage(wSwordsmen, 0, 0, 700, 700, x * size, y * size, size, size);
            break;
        case 'blackSwordsmen.png':
            ctx.drawImage(bSwordsmen, 0, 0, 700, 700, x * size, y * size, size, size);
            break;
        case 'whitePlagueDoctor.png':
            ctx.drawImage(wSwordsmen, 0, 0, 500, 500, x * size, y * size, size, size);
            break;
        case 'blackPlagueDoctor.png':
            ctx.drawImage(bSwordsmen, 0, 0, 500, 500, x * size, y * size, size, size);
            break;
        case 'whiteStarMan.png':
            ctx.drawImage(wStarMan, 0, 0, 500, 500, x * size, y * size, size, size);
            break;
        case 'blackStarMan.png':
            ctx.drawImage(bStarMan, 0, 0, 500, 500, x * size, y * size, size, size);
            break;

        case 'whiteKolba.png':
            ctx.drawImage(wKolba, 0, 0,1050, 1050, x * size, y * size, size, size);
            break;
        case 'blackKolba.png':
            ctx.drawImage(bKolba, 0, 0, 1050, 1050, x * size, y * size, size, size);
            break;
            
        case 'whiteFencer.png':
            ctx.drawImage(wFencer, 0, 0, 700, 700, x * size, y * size, size, size);
            break;
        case 'blackFencer.png':
            ctx.drawImage(bFencer, 0, 0, 700, 700, x * size, y * size, size, size);
            break;

        case 'whiteNorthernKing.png':
            ctx.drawImage(wNorthernKing, 0, 0, 700, 700, x * size, y * size, size, size);
            break;
        case 'blackNorthernKing.png':
            ctx.drawImage(bNorthernKing, 0, 0, 700, 700, x * size, y * size, size, size);
            break;
        case 'whiteShield.png':
            ctx.drawImage(wShield, 0, 0, 700, 700, x * size, y * size, size, size);
            break;
        case 'blackShield.png':
            ctx.drawImage(bShield, 0, 0, 700, 700, x * size, y * size, size, size);
            break;
        case 'whitePikeman.png':
            ctx.drawImage(wPikeman, 0, 0, 800, 800, x * size, y * size, size, size);
            break;
        case 'blackPikeman.png':
            ctx.drawImage(bPikeman, 0, 0, 800, 800, x * size, y * size, size, size);
            break;

        case 'whiteGeneral.png':
            ctx.drawImage(wGeneral, 0, 0, 600, 600, x * size, y * size, size, size);
            break;
        case 'blackGeneral.png':
            ctx.drawImage(bGeneral, 0, 0, 600, 600, x * size, y * size, size, size);
            break;

        case 'whiteDragon.png':
            ctx.drawImage(wDragon, 0, 0, 600, 600, x * size, y * size, size, size);
            break;
        case 'blackDragon.png':
            ctx.drawImage(bDragon, 0, 0, 600, 600, x * size, y * size, size, size);
            break;
        case 'whiteSleepingDragon.png':
            ctx.drawImage(wSleepingDragon, 0, 0, 600, 600, x * size, y * size, size, size);
            break;
        case 'blackSleepingDragon.png':
            ctx.drawImage(bSleepingDragon, 0, 0, 600, 600, x * size, y * size, size, size);
            break;

        //
        case 'whiteCyborg.png':
            ctx.drawImage(wCyborg, 0, 0, 600, 600, x * size, y * size, size, size);
        break;
        case 'blackCyborg.png':
            ctx.drawImage(bCyborg, 0, 0, 600, 600, x * size, y * size, size, size);
        break;

        case 'whiteBootvessel.png':
            ctx.drawImage(wBootvessel, -40, -80, 600, 600, x * size, y * size, size, size);
        break;
        case 'blackBootvessel.png':
            ctx.drawImage(bBootvessel, -40, -80, 600, 600, x * size, y * size, size, size);
        break;

        case 'blackCrystal.png':
            ctx.drawImage(bCrystal, -40, -40, 600, 600, x * size, y * size, size, size);
        break;
        case 'whiteCrystal.png':
            ctx.drawImage(wCrystal, -40, -40, 600, 600, x * size, y * size, size, size);
        break;

        case 'blackCrystalEmpowered.png':
            ctx.drawImage(bCrystalEmpowered, -40, -40, 600, 600, x * size, y * size, size, size);
        break;
        case 'whiteCrystalEmpowered.png':
            ctx.drawImage(wCrystalEmpowered, -40, -40, 600, 600, x * size, y * size, size, size);
        break;

        case 'blackJuggernaut.png':
            ctx.drawImage(bJuggernaut, -70, -50, 600, 600, x * size, y * size, size, size);
        break;
        case 'whiteJuggernaut.png':
            ctx.drawImage(wJuggernaut, -70, -80, 600, 600, x * size, y * size, size, size);
        break;

        case 'blackExecutor.png':
            ctx.drawImage(bExecutor,-100, -100, 600, 600, x * size, y * size, size, size);
        break;
        case 'whiteExecutor.png':
            ctx.drawImage(wExecutor, -100, -100, 600, 600, x * size, y * size, size, size);
        break;
    }
}


function drawLightedSquare(x, y, size) {
    if(size == undefined){
        size = 50;
    }
    ctx.fillStyle = lightedSquareColor;

    ctx.beginPath();
    ctx.fillRect(x, y, size, size);
    ctx.stroke();
    ctx.fillStyle = lightedSquareColor;

    ctx.beginPath();
    ctx.fillRect(x+1, y+1, size-2, size-2);
    ctx.stroke();
}

function drawColoredSquare(x, y, color, size) {
    ctx.fillStyle = color;

    ctx.beginPath();
    ctx.fillRect(x, y, size, size);
    ctx.stroke();

    ctx.fillStyle = color;

    ctx.beginPath();
    ctx.fillRect(x+1, y+1, size-2, size-2);
    ctx.stroke();
}
const AIColor = getParams(window.location.href).AIColor

// w.onmessage = function(){
//     console.log('vliza tuka')
// }


let ani = function(){
    animate(hotseatGame.returnState())
}


    const startHotseat = function(){
        const g = getSinglePlayerGame();
        return g;
    }
function drawWhiteSquare(x, y, size) {
    if(size == undefined){
        size = 50;
    }
    ctx.fillStyle = whiteSquareColor;

    ctx.beginPath();
    ctx.fillRect(x, y, size, size);
    ctx.stroke();

    ctx.fillStyle = whiteSquareColor;

    ctx.beginPath();
    ctx.fillRect(x+1, y+1, size-2, size-2);
    ctx.stroke();
}


function drawBlackSquare(x, y, size) {
    if(size == undefined){
        size = 50;
    }
    ctx.fillStyle = blackSquareColor;

    ctx.beginPath();
    ctx.fillRect(x, y, size, size);
    ctx.stroke();

    ctx.fillStyle = blackSquareColor;

    ctx.beginPath();
    ctx.fillRect(x+1, y+1, size-2, size-2);
    ctx.stroke();
}
    
    let squareLength = screen.width < screen.height? parseInt(screen.width/8) : parseInt(screen.height/10) 
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const exitButton = document.getElementById('exitButton')
    const flagImage = document.getElementById('flagImage')
    const hotseatGame = startHotseat();
    let mouseX;
    let mouseY;
    let st = undefined;
    let endGame = false;
    let boardHeight;
    let boardWidth;
    let state;
    let hoveredPiece;
    let playerRef;
    let w;

    hotseatGame.join('white', 'white');
    hotseatGame.join('black','black');

    hotseatGame.state.pieces.length = 0;
    hotseatGame.state.board.length = 0;
  //  evaluateBoard('white', hotseatGame.state.pieces)
    for (let x = 0; x <= 7; x++) {
        for (let y = 0; y <= 7; y++) {
            hotseatGame.state.board.push({ light: false, x: x, y: y })
        }
    }

    hotseatGame.state.gameType = 'raceChoiceChess'
    hotseatGame.state.turn = 'menu'
    hotseatGame.state.whiteRace = getParams(window.location.href).whiteRace || 'medieval'
    hotseatGame.state.blackRace = getParams(window.location.href).blackRace || 'bug'
    hotseatGame.state.turn = 'black'

    raceChoiceChess(hotseatGame.state.pieces,hotseatGame.state.board,hotseatGame.state.whiteRace,hotseatGame.state.blackRace)
    function animate(secretState){
        //Draw the game
        const myTurnH1 = document.getElementById('turn');
        canvas.width = squareLength * boardWidth + squareLength;
        canvas.height = squareLength * boardWidth + squareLength;
        state = secretState;
        if(hoveredPiece){
            if(hoveredPiece.color != hotseatGame.state.turn && hotseatGame.state.turn != undefined){
                lightBoardFE(hoveredPiece,state,'red','grey')
            }
        }
        if (state.pieces) {
            if(exitButton.hasAttribute('style')){
                exitButton.removeAttribute('style')
            }
            //Draw Squares
            const me = document.getElementById('blackClock');
            const enemy = document.getElementById('whiteClock');
            const body = document.getElementsByTagName('body')[0];
            const forfeitTextButton = document.getElementById('forfeitText');
            if (state.turn == 'black') {
                body.style.background = blackSquareColor
                me.style.color = whiteSquareColor;
                enemy.style.color = whiteSquareColor;
            }
            else {
                me.style.color = blackSquareColor;
                enemy.style.color = blackSquareColor;
                body.style.background = whiteSquareColor
            }
            myTurnH1.innerText = state.message || '';
            const height = getMaxX(state.board,'y')
            if(state.playerRef !== undefined){
                playerRef = state.playerRef
            }

            boardWidth  = state.board.reduce((accumulator, currentValue) => {
                if(accumulator > currentValue.x){
                    return accumulator
                }
                else{
                    return currentValue.x
                }
            })
            boardHeight  = state.board.reduce((accumulator, currentValue) => {
                if(accumulator > currentValue.y){
                    return accumulator
                }
                else{
                    return currentValue.y
                }
            })

            state.board.forEach((sq,index) => {
                let y = sq.y;
                let x = sq.x;


                let orderFirst = true;
                if(y%2 != 0){
                    orderFirst = false;
                }
                if (!sq.light && !sq.special && !sq.red) {
                    if(orderFirst){
                        if(x % 2 != 0){
                            drawBlackSquare(x * squareLength, y * squareLength, squareLength)
                        }
                        else{
                            drawWhiteSquare(x * squareLength, y * squareLength, squareLength)
                        }
                    }
                    else{
                        if(x % 2 != 0){
                            drawWhiteSquare(x * squareLength, y * squareLength, squareLength)
                        }
                        else{
                            drawBlackSquare(x * squareLength, y * squareLength, squareLength)
                        }
                    }
                    if(state.pieceSelected){
                        if(x == state.pieceSelected.x && y == state.pieceSelected.y){
                            drawColoredSquare(x*squareLength, y*squareLength,availableSquareColor, squareLength)
                        }
                    }
                }
                else if(sq.special){
                    drawColoredSquare(x*squareLength, y * squareLength, '#855bb3', squareLength)
                }
                else {
                    drawLightedSquare(x * squareLength, y * squareLength, squareLength);
                }
                if(sq.red){
                    drawColoredSquare(x*squareLength, y * squareLength, dangerSquareColor, squareLength)
                }
                else if(sq.grey){
                    drawColoredSquare(x*squareLength, y * squareLength, blockedSquareColor, squareLength)
                }

                
                
            })
            if(state.oldMove){
                const oldSquare = findSquareByXY(state.board,state.oldMove.oldX, state.oldMove.oldY);
                const newSquare = findSquareByXY(state.board,state.oldMove.currentX, state.oldMove.currentY);
                if(hotseatGame.state.turn === 'black'){
                    if(!oldSquare.light){
                        drawColoredSquare(state.oldMove.oldX*squareLength, state.oldMove.oldY*squareLength,oldMoveSquareColor, squareLength)
                    }
                    if(!newSquare.light){
                        drawColoredSquare(state.oldMove.currentX*squareLength, state.oldMove.currentY*squareLength,oldMoveSquareColor, squareLength)
                    }
                }
                else if(hotseatGame.state.turn === 'white'){
                    if(!oldSquare.light){
                        drawColoredSquare(state.oldMove.oldX*squareLength, state.oldMove.oldY*squareLength,oldMoveSquareColor, squareLength)
                    }
                    if(!newSquare.light){
                        drawColoredSquare(state.oldMove.currentX*squareLength, state.oldMove.currentY*squareLength,oldMoveSquareColor, squareLength)
                    }
                }

            }

            //Draw Pieces
            state.pieces.forEach((piece) => {
                drawPiece(piece.x, piece.y, piece.icon, squareLength)
            })
            if (state.won) {
                if (state.won == 'black') {
                    
                    forfeitTextButton.innerText = 'Black Won'
                }
                else if (state.won == 'white') {

                    forfeitTextButton.innerText = 'White Won'

                }
            }


        }
        else {
            myTurnH1.innerText = 'Waiting for Opponent'
        }

    } 
    AISetup(hotseatGame,'white');

    canvas.addEventListener('click', (e) => {
        const hotseat = true;
        const state = hotseatGame.state;
        const AIvsAI = false;
        if(w){
            w.terminate();
        }
        if(AIvsAI)
        {
            state.pieces = state.pieces.sort((a, b) => 0.5 - Math.random());
            if(state.turn === 'black'){
                
                w = new Worker("src/webworker.js");

                w.postMessage(JSONfn.stringify({state:state, color:'black', depth:500}));
                w.onmessage = function(event){
                    let move = JSONfn.parse(event.data)
                    AIMove(move.pieceCounter, move.xClicked, move.yClicked, 'black')
                    if(state.turn === 'black'){
                        w.postMessage(JSONfn.stringify({state:state, color:'white', depth:500, removedTurns:[...event.data.removedTurns, {...move}]}));
                    }
                }
            }
            if(state.turn === 'white'){
                w = new Worker("src/webworker.js");

                w.postMessage(JSONfn.stringify({state:state, color:'white', depth:500}));
                w.onmessage = function(event){
                    let move = JSONfn.parse(event.data)
                    AIMove(move.pieceCounter, move.xClicked, move.yClicked, 'white')
                    if(state.turn === 'white'){
                        
                        w.postMessage(JSONfn.stringify({state:state, color:'white', depth:500, removedTurns:[...event.data.removedTurns, {...move}]}));
                    }
                }
                // let move = minimax(state,'white',200)

                
                // AIMove(move.pieceCounter, move.xClicked, move.yClicked)
            }
        }
        else if(hotseat || state.turn !=  AIColor){
            var element = canvas, offsetX = 0, offsetY = 0, mx, my;

            // Compute the total offset. It's possible to cache this if you want
            if (element.offsetParent !== undefined) {
                do {
                    offsetX += element.offsetLeft;
                    offsetY += element.offsetTop;
                } while ((element = element.offsetParent));
            }

            mx = e.pageX - offsetX;
            my = e.pageY - offsetY;
            

            hotseatGame.move(hotseatGame.state.turn,{ x: parseInt(mx / squareLength), y: parseInt(my / squareLength) })
            state.pieces = state.pieces.sort((a, b) => 0.5 - Math.random());
            if(state.turn === AIColor){
                w = new Worker("src/webworker.js");

                w.postMessage(JSONfn.stringify({state:state, color:AIColor, depth:500}));
                w.onmessage = function(event){
                    let move = JSONfn.parse(event.data)
                    AIMove(move.pieceCounter, move.xClicked, move.yClicked, AIColor)
                }
                // let move = minimax(state,'white',200)

                
                // AIMove(move.pieceCounter, move.xClicked, move.yClicked)
            }
            else if(AIColor === 'allAI'){
                w = new Worker("src/webworker.js");
                console.log(state.turn,' wtf?   ')
                w.postMessage(JSONfn.stringify({state:state, color:state.turn, depth:500}));
                w.onmessage = function(event){
                    let move = JSONfn.parse(event.data)
                    AIMove(move.pieceCounter, move.xClicked, move.yClicked, state.turn)
                    w.postMessage(JSONfn.stringify({state:state, color:state.turn, depth:500}));

                }
            }
        }

        function getRndInteger(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }


        
        
        //
        // hotseatGame.move('black',  { x: parseInt(mx / squareLength), y: parseInt(my / squareLength) })
        //evaluateBoard('white',state.pieces,state);

    })

    canvas.addEventListener('mousemove', (e) => {
        let {x, y} = getMousePos(canvas,e);
        if(!state || !state.pieces){
            return;
        }
        hoveredPiece = pieceFromXY(parseInt(x / squareLength), parseInt(y / squareLength),state.pieces)
        // animate(state)
    })

    setInterval(ani, 100)


</script>

</html>